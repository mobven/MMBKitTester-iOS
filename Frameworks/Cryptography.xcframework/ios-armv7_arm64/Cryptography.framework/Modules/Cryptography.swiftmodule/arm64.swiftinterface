// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.2.4 (swiftlang-1103.0.32.9 clang-1103.0.32.53)
// swift-module-flags: -target arm64-apple-ios10.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Cryptography
import CommonCrypto
@_exported import Cryptography
import Foundation
import Security
import Swift
public class EncryptedMessage : Cryptography.Message {
  final public let data: Foundation.Data
  required public init(data: Foundation.Data)
  public func decrypted(with key: Cryptography.PrivateKey, padding: Cryptography.Padding) throws -> Cryptography.ClearMessage
  @objc deinit
}
public class PublicKey : Cryptography.Key {
  final public let reference: Security.SecKey
  final public let originalData: Foundation.Data?
  public func pemString() throws -> Swift.String
  required public init(reference: Security.SecKey) throws
  required public init(data: Foundation.Data) throws
  public static func publicKeys(pemEncoded pemString: Swift.String) -> [Cryptography.PublicKey]
  @objc deinit
}
public protocol Key : AnyObject {
  var reference: Security.SecKey { get }
  var originalData: Foundation.Data? { get }
  init(data: Foundation.Data) throws
  init(reference: Security.SecKey) throws
  init(base64Encoded base64String: Swift.String) throws
  init(pemEncoded pemString: Swift.String) throws
  init(pemNamed pemName: Swift.String, in bundle: Foundation.Bundle) throws
  init(derNamed derName: Swift.String, in bundle: Foundation.Bundle) throws
  func pemString() throws -> Swift.String
  func data() throws -> Foundation.Data
  func base64String() throws -> Swift.String
}
extension Key {
  public func base64String() throws -> Swift.String
  public func data() throws -> Foundation.Data
  public init(base64Encoded base64String: Swift.String) throws
  public init(pemEncoded pemString: Swift.String) throws
  public init(pemNamed pemName: Swift.String, in bundle: Foundation.Bundle = Bundle.main) throws
  public init(derNamed derName: Swift.String, in bundle: Foundation.Bundle = Bundle.main) throws
}
@objc(PublicKey) public class _objc_PublicKey : ObjectiveC.NSObject, Cryptography.Key {
  @objc public var reference: Security.SecKey {
    @objc get
  }
  @objc public var originalData: Foundation.Data? {
    @objc get
  }
  @objc public func pemString() throws -> Swift.String
  @objc public func data() throws -> Foundation.Data
  @objc public func base64String() throws -> Swift.String
  required public init(swiftValue: Cryptography.PublicKey)
  @objc required public init(data: Foundation.Data) throws
  @objc required public init(reference: Security.SecKey) throws
  @objc required public init(base64Encoded base64String: Swift.String) throws
  @objc required public init(pemEncoded pemString: Swift.String) throws
  @objc required public init(pemNamed pemName: Swift.String, in bundle: Foundation.Bundle) throws
  @objc required public init(derNamed derName: Swift.String, in bundle: Foundation.Bundle) throws
  @objc public static func publicKeys(pemEncoded pemString: Swift.String) -> [Cryptography._objc_PublicKey]
  @objc deinit
  @objc override dynamic public init()
}
@objc(PrivateKey) public class _objc_PrivateKey : ObjectiveC.NSObject, Cryptography.Key {
  @objc public var reference: Security.SecKey {
    @objc get
  }
  @objc public var originalData: Foundation.Data? {
    @objc get
  }
  @objc public func pemString() throws -> Swift.String
  @objc public func data() throws -> Foundation.Data
  @objc public func base64String() throws -> Swift.String
  required public init(swiftValue: Cryptography.PrivateKey)
  @objc required public init(data: Foundation.Data) throws
  @objc required public init(reference: Security.SecKey) throws
  @objc required public init(base64Encoded base64String: Swift.String) throws
  @objc required public init(pemEncoded pemString: Swift.String) throws
  @objc required public init(pemNamed pemName: Swift.String, in bundle: Foundation.Bundle) throws
  @objc required public init(derNamed derName: Swift.String, in bundle: Foundation.Bundle) throws
  @objc deinit
  @objc override dynamic public init()
}
@_hasMissingDesignatedInitializers @objc(VerificationResult) public class _objc_VerificationResult : ObjectiveC.NSObject {
  @objc final public let isSuccessful: Swift.Bool
  @objc deinit
  @objc override dynamic public init()
}
@objc(ClearMessage) public class _objc_ClearMessage : ObjectiveC.NSObject, Cryptography.Message {
  @objc public var base64String: Swift.String {
    @objc get
  }
  @objc public var data: Foundation.Data {
    @objc get
  }
  required public init(swiftValue: Cryptography.ClearMessage)
  @objc required public init(data: Foundation.Data)
  @objc required public init(string: Swift.String, using rawEncoding: Swift.UInt) throws
  @objc required public init(base64Encoded base64String: Swift.String) throws
  @objc public func string(encoding rawEncoding: Swift.UInt) throws -> Swift.String
  @objc public func encrypted(with key: Cryptography._objc_PublicKey, padding: Cryptography.Padding) throws -> Cryptography._objc_EncryptedMessage
  @objc public func signed(with key: Cryptography._objc_PrivateKey, digestType: Cryptography._objc_Signature.DigestType) throws -> Cryptography._objc_Signature
  @objc public func verify(with key: Cryptography._objc_PublicKey, signature: Cryptography._objc_Signature, digestType: Cryptography._objc_Signature.DigestType) throws -> Cryptography._objc_VerificationResult
  @objc deinit
  @objc override dynamic public init()
}
@objc(EncryptedMessage) public class _objc_EncryptedMessage : ObjectiveC.NSObject, Cryptography.Message {
  @objc public var base64String: Swift.String {
    @objc get
  }
  @objc public var data: Foundation.Data {
    @objc get
  }
  required public init(swiftValue: Cryptography.EncryptedMessage)
  @objc required public init(data: Foundation.Data)
  @objc required public init(base64Encoded base64String: Swift.String) throws
  @objc public func decrypted(with key: Cryptography._objc_PrivateKey, padding: Cryptography.Padding) throws -> Cryptography._objc_ClearMessage
  @objc deinit
  @objc override dynamic public init()
}
@objc(Signature) public class _objc_Signature : ObjectiveC.NSObject {
  @objc public enum DigestType : Swift.Int {
    case sha1
    case sha224
    case sha256
    case sha384
    case sha512
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc public var base64String: Swift.String {
    @objc get
  }
  @objc public var data: Foundation.Data {
    @objc get
  }
  required public init(swiftValue: Cryptography.Signature)
  @objc public init(data: Foundation.Data)
  @objc required public init(base64Encoded base64String: Swift.String) throws
  @objc deinit
  @objc override dynamic public init()
}
public protocol Message {
  var data: Foundation.Data { get }
  var base64String: Swift.String { get }
  init(data: Foundation.Data)
  init(base64Encoded base64String: Swift.String) throws
}
extension Message {
  public var base64String: Swift.String {
    get
  }
  public init(base64Encoded base64String: Swift.String) throws
}
public typealias Padding = Security.SecPadding
public enum SwiftyRSA {
  @available(iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  public static func generateRSAKeyPair(sizeInBits size: Swift.Int) throws -> (privateKey: Cryptography.PrivateKey, publicKey: Cryptography.PublicKey)
}
public class Signature {
  public enum DigestType {
    case sha1
    case sha224
    case sha256
    case sha384
    case sha512
    public static func == (a: Cryptography.Signature.DigestType, b: Cryptography.Signature.DigestType) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  final public let data: Foundation.Data
  public init(data: Foundation.Data)
  convenience public init(base64Encoded base64String: Swift.String) throws
  public var base64String: Swift.String {
    get
  }
  @objc deinit
}
public class ClearMessage : Cryptography.Message {
  final public let data: Foundation.Data
  required public init(data: Foundation.Data)
  convenience public init(string: Swift.String, using encoding: Swift.String.Encoding) throws
  public func string(encoding: Swift.String.Encoding) throws -> Swift.String
  public func encrypted(with key: Cryptography.PublicKey, padding: Cryptography.Padding) throws -> Cryptography.EncryptedMessage
  public func signed(with key: Cryptography.PrivateKey, digestType: Cryptography.Signature.DigestType) throws -> Cryptography.Signature
  public func verify(with key: Cryptography.PublicKey, signature: Cryptography.Signature, digestType: Cryptography.Signature.DigestType) throws -> Swift.Bool
  @objc deinit
}
public enum SwiftyRSAError : Swift.Error {
  case pemDoesNotContainKey
  case keyRepresentationFailed(error: CoreFoundation.CFError?)
  case keyGenerationFailed(error: CoreFoundation.CFError?)
  case keyCreateFailed(error: CoreFoundation.CFError?)
  case keyAddFailed(status: Darwin.OSStatus)
  case keyCopyFailed(status: Darwin.OSStatus)
  case tagEncodingFailed
  case asn1ParsingFailed
  case invalidAsn1RootNode
  case invalidAsn1Structure
  case invalidBase64String
  case chunkDecryptFailed(index: Swift.Int)
  case chunkEncryptFailed(index: Swift.Int)
  case stringToDataConversionFailed
  case dataToStringConversionFailed
  case invalidDigestSize(digestSize: Swift.Int, maxChunkSize: Swift.Int)
  case signatureCreateFailed(status: Darwin.OSStatus)
  case signatureVerifyFailed(status: Darwin.OSStatus)
  case pemFileNotFound(name: Swift.String)
  case derFileNotFound(name: Swift.String)
  case notAPublicKey
  case notAPrivateKey
}
public class PrivateKey : Cryptography.Key {
  final public let reference: Security.SecKey
  final public let originalData: Foundation.Data?
  public func pemString() throws -> Swift.String
  required public init(reference: Security.SecKey) throws
  required public init(data: Foundation.Data) throws
  @objc deinit
}
extension Cryptography._objc_Signature.DigestType : Swift.Equatable {}
extension Cryptography._objc_Signature.DigestType : Swift.Hashable {}
extension Cryptography._objc_Signature.DigestType : Swift.RawRepresentable {}
extension Cryptography.Signature.DigestType : Swift.Equatable {}
extension Cryptography.Signature.DigestType : Swift.Hashable {}
